# BTree индекс по умолчанию
- Индексы принято называть по паттерну:
    idx_<table_name>_<column_name>_<other>
```SQL
CREATE INDEX index_name ON table_name (column_name);
```
- по умолчанию создаётся btree сбалансированное дерево
    также для unique, primary key
- btree поддерживает операторы:
    <,>, <=, >=, =
    - поддерживает
        LIKE 'abc%'
        Индексирует NULL
    - сложность поиска O(logN)
- если операция в запросе не поддерживается индексом, например >,
    то сканирование не будет индексным

# Индекс по Хэшу
```SQL
CREATE INDEX index_name ON table_name USING HASH (column_name);
```
- Поддерживает только оператор '='
- Не отражается в журнале предзаписи WAL
    - как понял, что при какой-либо катастрофе с бд
        сможем вернуть только те данные, которые записаны на диск
- Не рекомендуется к применению
- Сложность O(1)

# Специализированные индексы
## GIST Обобщённое дерево поиска
- Применяется для: 
    геометрических типов данных 
    текстовых для организации полнотекстового поиска
- Занимает меньше места, чем GIN для организации
    - может быть менее эффективен засчёт доп проверок
## GIN Обобщённый обратный
- Применяется для:
    массива
    набора значений
    range
    JSONB
    ключ:значение
    полнотекстовый поиск
## SP-GIST (GIST с двоичным разбиением пространства)
- Применяется для:
    наборов данных с естественной упорядоченностью,но не являющимися сбалансированными
    - Например: телефонные номера по странам
## BRIN (блочно-диапазонный)
- Потенциально полезен на огромных наборах данных, которые подразумевают
    естественную упорядоченность (почтовые индексы, таймстэмпы)

# EXPLAIN query
- позволяет посмотреть план выполнения запроса
    - не выполняет сам запрос, а только предоставляет план
# EXPLAIN ANALYZE query
- предоставляет план и реальность
# ANALYZE
- собирает статистику по данным таблицы
```SQL
ANALYZE [table_name[(column1, column2)]]
```
- Запускать как минимум один раз в день
    - не так страшно, по умолчанию включён 
        autovacuum, к-й в том числе запускает ANALYZE

# Индексный поиск
- можно строить индексы сразу по нескольким  столбцам
- при построении индекса по двум столбцам, нап:
```SQL
CREATE INDEX idx_users_first_last_name ON users(first_name, last_name)
```
- Мы можем получать индексный поиск, как сразу по двум, так и по одному(первому) столбцу
    в данном случае first_name, нап:
```SQL
EXPLAIN
SELECT * --Получим индексный поиск сразу по двум столбцам
FROM users
WHERE first_name LIKE 'An%' and last_name LIKE 'Op%';
EXPLAIN
SELECT * --Получим индексный поиск по first_name
FROM users
WHERE first_name LIKE 'El%';
EXPLAIN
SELECT * --Но здесь получим последовательный поиск
FROM users
WHERE last_name LIKE 'Sp%';
```
- Для того, чтобы получить индексный поиск по всем столбцам сразу и 
    по отдельности для каждого - следует создать новый индекс 
    для последующих после первого столбцов
## Поиск по столбцу с индексом с использованием функций(выражений)
- Пример:
```SQL
EXPLAIN
SELECT * --Будет использован последовательный поиск, даже
FROM users --учитывая то, что у нас уже создан индекс на first_name
WHERE UPPER(first_name) LIKE 'AB%' 
```
- Чтобы избежать последовательного поиска при уже существующем индексе,
    но с функциями нужно либо:
    - Продумывать бизнес логику приложения
    - Создавать дополнительные индексы с учётом этих функий,
        например для LOWER(users(first_name)):
        ```SQL
        CREATE INDEX idx_users_first_name_lower ON users(LOWER(first_name));
        ```
- Но опять же получаем проблему с поиском по регулярным выражениям
## Индекс для поиска по регулярным выражениям
- Если результирующий набор очень большой, нап %b% - планировщик
    будет использовать seq scan, однако при малых выборочных, нап %crea%
    наборах будет применяться наш индекс
- Созданиеиндекса для полного поиска по тексту
```SQL 
CREATE EXTENSION pg_trgm; --Использование расширения
CREATE INDEX trgm_index_user_first_name ON user USING gin (first_name gin_trgm_ops);
```